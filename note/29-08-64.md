#### Why TypeScript?

- การทำงานต่อจากคนอื่นโดยทั่วไปยาก เราไม่สามารถรู้ได้ว่าตัวแปรนี้ ชื่อของมันต้องการสื่ออะไร เขาอาจจะตั้งชื่อตัวแปรหลอกเราก็ได้ **Naming Lies**
- Typescript เข้ามาช่วยในการทำงานได้ง่ายขึ้น ระบุTypeของตัวแปรโดยตรงว่าต้องเป็นTypeอะไร

```
uploadFiles(files)
const file = new File()
uploadFile([file])
```

**_void === function ที่ไม่มีการ return อะไรออกมา (undefine)_**

#### You have been using TypeScript all along.

- ใน Javascript ก็มีการใช้ Type อยู่ แต่เป็น type: any _VSCode ใช้ Typescript Complier (จะแสดงใน Tooltip เมื่อเราเอาเมาส์ชี้ไปที่ชื่อ Fn)_

**_ใน comment (/\* \*/) ของJS สามารถใส่ @ ระบุได้ว่าตัวแปรพวกนี้ Type เป็นอะไร เป็นแค่การทำ auto doc (Tooltip VSCode เปลี่ยนด้วย) สำหรับให้คนอื่นเข้าใจ code เราง่ายขึ้น (แต่ไม่ได้ fix ว่าต้องเป็น Type นั้นๆ)_**

**คำสั่ง @**

- @param _variable_(_type_) === กำหนดให้ตัวแปรนั้นๆมี _type_ เป็นอะไร
- @return(_type_) === กำหนดให้การ return ของฟังก์ชันออกมา _type_ เป็นอะไร
- @type {{_variable_: _type_}} === กำหนดให้ตัวแปรใน Object

```
//js

const add1 = (a, b) => a + b;

/**
 * @param a{number}
 * @param b{number}
 * @returns(number)
 */

const add2 = (a, b) => {
  return a + b;
};
```

_เมื่อเอาเมาส์ไปชี้ add1 กับ add2 แสดงผลใน Tooltip ต่างกัน add1 จะเป็น any ทั้งค่าที่รับและค่าที่returnออกมา, add2 จะเป็น number ทั้งหมด_

```
//js

const person1 = {
  nickname: "BOB",
  age: 15,
};

/**
 * @type {{nickname: string}}
 */

const person2 = {
  nickname,
};
```

_person1 เมื่อมีการระบุ property value แล้ว ใน Tooltip จะแสดงผลเป็น Type ของ value นั้นๆ_
_person2 เป็นการใช้ @type ในการระบุ Type ให้กับ property value_

**_ใน TypeScript มีการกำหนด type declaration แยกออกมาจาก File .ts ที่เราเขียน code เป็นหลักได้ > .d.ts (d ย่อมาจาก definition)_**

ในการเริ่มเรียน TypeScript ในช่วงแรกให้เริ่มจากเขียน Javascript ก่อน

###### Type

**Type Inference**: เป็นตัวที่ทำให้ TypeScript จะรู้ได้ว่าฟังก์ชันของเราจะทำอะไร

#### 3 Primitives: Variable Types & Inference

**Primitives**

**Literals**

- เป็นการกำหนดค่าของตัวแปรให้เป็นค่านั้นๆ มีทั้งแบบTypeนั้นเฉยๆ หรือค่าตัวแปรต้องตรง _แบบเปีะๆด้วย (Literally)_

```
const name1 = "Bob Alice"; // name1's Primitives type === "Bob Alice" <- นี่คือ Literals แบบ Literally ที่ต้องเป็นแบบนี้เป๊ะๆ (string คำว่า Bob Alice)

const sayHello = (name: "hello") => `Say ${name}`;
sayHello("hi"); // <- ERROR Fn รับค่าแค่ string: "hello" เท่านั้น
```

###### Exercise

**จงเขียนฟังชันก์ addInt ที่รับ a, b ที่มีค่าเท่ากับ 50 และ 30 ตามลำดับ**

```
const addInt = (a: 50, b: 30) => a + b;
addInt(50, 30);
```

###### Developer Experience

```
const sayHello1 = (name: "hello" | "hi") => `Say ${name}`;
sayHello1("hello");
```

- สามารถกำหนดค่าเจาะจงให้กับ TypeScript มากว่า 1 ค่าได้ ด้วย Union _"|"_ -> ทำให้สามารถเลือก parameter ของฟังก์ชันได้ (Auto complete มาจากระบบ Language Server Protocol มีทุก Editor) === _Compile-Time Guarantee_
- _Union ("|")_ ทำงานคล้ายกับหรือ ("||") ใน JavaScript

#### Functions

- ไม่ใส่ return === _void_
- ควรใส่ return Type ให้กับ Fn เมื่อมีการ export ออกมา (กฎ eslint: explicit-module-boundary-type)

**TypeScript Strict Mode**

- โดยปกติ เนื่องจาก TypeScript ต่อยอดมาจาก JavaScript การเขียนcodeเลยไม่เคร่งมากนัก
- Strict Mode จะทำให้ TypeScript เคร่งกฎในการเขียนมากขึ้น

```
npx tsc -init
```

- คำสั่งข้างต้น จะทำการสร้าง tsconfig ขึ้นมา เพื่อเปิดใช้งาน Strict Mode
- Strict Mode ทำให้ code ข้างล่าง Error (ปกติจะไม่ Error)

```
const add2 = (a: number, b: number): number | undefined => {
  return undefined; // Error ถ้าไม่กำหนด Union ตรง Return Type
  return a + b;
};
```

#### Arrays vs Tuples

###### Arrays

- ถ้าเราประกาศ declaration Type ไปแล้ว แต่ถ้าทำการ assign ค่าไม่ตรงกับ Type === Error

```
const hello: "hello" = "Hello"; // Error ประกาศ declaration Literals กับ Assign ไม่ตรงกัน
```

**Type number === int, float, negative, zero _เรื่องความกว้าง/แคบของType_**

- Array ประกาศ declaration Type -> **_Type_\[\]** เป็นการประกาศว่า ทุกตัวใน Array ต้อง Type นี้ (ถ้ามากกว่า 1 Type ใช้ Union ได้)
- Nested Array -> **_Type_\[\]\[\]**

```
const birthDay1: number[] = [7, 11, 2001];
const birthDay2: (number | string)[] = ["WED", "NOV", 2001];
const nestArr: number[][] = [
  [1, 2],
  [3, 4],
];
```

**TypeScript มีความสามารถคล้ายกับ JavaScript ในการประกาศType Inference Type ดีมาก ถ้าตัว Type ไม่ซับซ้อน**

###### Exercise

**สร้าง nest-Arr ที่รับได้ true กับ 5 เท่านั้น**

```
const grid: (true | 5)[][] = [[true], [5]];
```

###### Tuples

- ปกติใน useState Function จะมี parameter เป็น number และตัว set ค่าเป็น function
- แต่ถ้ามีคนเขียนแบบด้านล่าง มันจะ Error ตอน run ทันที เนื่องจากมัน Union ว่าจะ number | function ก่อนก็ได้

```
function useState() {
  return [1, () => {}];
}

const [setCounter, counter] = useState();
```

- ใช้ **_Tuples_** ในการช่วยเช็ค -> Tuples คือ Array ที่กำหนดการเรียงลำดับไว้ชัดเจน
- กำหนดให้กับ Function useState จะได้ไม่ Error ใน case แปลกๆ

```
function useState(): [number, () => void] {
  return [1, () => {}];
}
```

###### EXERCISE useEffect in TS

```
function useEffect1(arg1: () => () => void, arg: unknown[]): void {}
```

- Type inference ของ TS จะพยายามให้กว้างที่สุดก่อนเสมอ
- เราสามารถใส่ key ให้กับ Tuples ได้ (ถ้าใส่แล้ว ต้องใส่ทุกตัว) ช่วยทำให้คนอ่าน code อ่านง่ายขึ้น ว่ามันเป็น Type ของอะไร

#### Any, Unknown, Never, Void

- Any === disable การเช็ค Type ของ TypeScript Complier
- ###### Unknown === ไม่เช็ค Type แต่สามาถทำงานกับ Type อย่างปลอดภัยได้ _**ใช้กับเวลาที่เรายังไม่มั่นใจว่า Type ของตัวนี้จะเป็นอะไร** เวลารับค่าเข้ามาแล้วเช็คว่าเป็นอะะไรอีกที่ ในfunction (Type Guard)_
  - **Type Guard === กระบวนการ TypeScript ที่ทำเป็นเงื่อนไขเอาไว้ให้จำกัด/เปลี่ยนแปลง Type ให้แคบลงกว่าเดิม**
    - typeof
    - predicate === function return Boolean (true / false)
      - ใช้ในการสื่อสารกับ TypeScript ว่า Type ของ parameter มันเป็นอะไร
      - TS ไม่สนว่า logic ที่ return Boolean ออกมาจาก predicate เป็นอะไร (เกิดขึ้นตอน program ถูก run)
      - TS สนใจแค่ operate ตอน complie-time

_TS ตอน complie ทำแค่ 1. Type Check การทำงาน 2. ส่ง strict Type declaration ออกไป_

```
// typeof
function add3(a: unknown, b: unknown) {
  if (typeof a === "string" || typeof b === "string") {
    return console.log("this is string");
  }
  if (typeof a === "number" && typeof b === "number") {
    return a + b;
  }
}

// predicate
const isPerson = (person: unknown): person is { name: string } => true;

function getName(person: unknown) {
  if (isPerson(person)) {
    person.name;
  }
}
```

- Void === Type ไม่มีการกำหนดค่า ส่วนใหญ่จะเป็นการบอกค่า return ที่ไม่คืนค่าอะไรออกมา
- Never === ใช้ใน Advance type เป็นหลัก ใช้ไว้สื่อสารกับ Programmer ที่เขียน code ด้วยกัน ว่า function จะไม่มีการ return แน่ๆ

```
function infiniteLoop(): never {
  while(true) {}
}
```

#### Null, Undefined

- _"Undefined is not a function"_ Simple Error เกิดขึ้นกับ code ที่ไม่มีการ type strict
- useCase เช่น ในการเขียน code เล่นกับ API อาจเกิด Error ขึ้นได้ _เช่น data ที่ได้มาไม่มีแต่เราไม่รู้ หรือ คุยกันในทีมไม่ชัดเจนว่ามี type อะไรบ้าง_
- ช่วยให้ในการเขียนโปรแกรมเรารู้ contract (การติดต่อและการใช้งานที่เกี่ยวข้องกัน) ของ code
- ในการเจาะ Object เช่น Object ที่ fetch ข้อมูลมาจาก API ใน JS จะต้องใส่ ?(OptionalChainning) เอง แต่ใน TS ถ้าเรากำหนด Type แบบ Union ไว้ว่ามันอาจเป็น undefined/null มันจะ autoComplete ? ให้

```
// JS
const getUser = () => {};

const user = getUser();

user.address.province; // ERROR: cannot read property 'address' of undefined

function getUsername(): string | null {
  return "Hello";
}

// TS
const username = getUsername();
username?.charCodeAt(); // auto optionalChainning
```

_ความแตกต่างระหว่าง undefined กับ null === undefined แทนว่าตัวแปรที่ไม่ประกาศ value อะไรไว้, null คือเรารู้แล้วว่ามันเป็น null (ต้องประกาศเอง)_
_early return แบบไม่มีอะไรออกไป Type === void/undefined_

#### Inline object typing (fixed keys, string keys; Index Types and Index Signatures)

**เราต้อง Type ให้กับ Object ด้วย**
1 ต้องการ Type Inference ที่แคบลง หรือ เป็น Literal ไปเลย
2 เราอยากประกาศให้ Function

- Type inference TS เดา type structure ให้เราได้ แต่จะกว้างที่สุด
- _ใส่การกำหนด type : ต่อจากประกาศตัวแปร ลงไปตรงๆ เรียก_ **Inline Type Annotation**

```
// Inline Type Annotation - fixed keys
const person1: {
  name: string;
  address: {
    province: {
      title: string;
    };
  }[];
} = {
  name: "Bob",
  address: [
    {
      province: { title: "Bangkok" },
    },
  ],
};
```

- Index Type === กำหนด type ของ key และ value -> **[key: _type_]: _type_**

```
//Index Types
//Type key === string, value === number
const person2: {
  [key: string]: number;
} = {
  id: 1,
};
```

###### Type-alias

- Type-alias คือการประกาศ Type แบบ internal (แยกออกไปเป็น type ={} แล้วเอาไปอิงกับตัวแปรที่ต้องการกำหนด Type)
- Type-alias เวลาเราเอาเมาส์ไปชี้ตัวระบุ Type จะแสดงรูปแบบการกำหนด Type ของเรา

```
// type-alias
type Person1 = {
  firstname: string;
  lastname: string;
};

const person4: Person1 = {
  firstname: "a",
  lastname: "b",
};
```

###### Interface

- การสร้างคล้ายๆ Class Constructer ที่กำหนด Type หลายๆตัวในนี้ได้ แล้วนำ _ชื่อ_ ไปใส่ในตัวแปรที่ต้องการกำหนด Type แทนการเขียน Type
- ชื่อ interface ขึ้นด้วยตัวใหญ่ (Best-practice)
- เวลาเราเอาเมาส์ไปชี้ตัวระบุ Type จะแสดงแค่ว่ามันรับ Interface มาจากตัวไหน มันจะไม่แสดงว่า Interface นั้นกำหนด Type ข้างในแบบไหน

```
// Simple Interface
interface IntPerson1 {
  tel: number;
}

const personTel: IntPerson1 = {
  tel: 1234,
};
```

###### Inheritance

ทำ inheritance ได้ 2 แบบ

1. _someTypeDefi_ extend _someTypeDefi_
2. ใช้ intersect **_(& === intersect)_** -> _someTypeDefi_ & _someTypeDefi_

**inheritance-extends**

```
// inheritance-extends
interface IntPerson1 extends TelType {
  tel: number;
}

interface TelType {
  telType: string;
}

const personTel: IntPerson1 = {
  tel: 1234,
  telType: "home",
};
```

**inheritance-intersect**

```
//type-alias & interface
interface IntRole {
  role: string;
}

type TPerson1 = {
  name: string;
} & IntRole;
```

```
//type-alias & type-alias (ตั้ง type แยก / ต่อกันไปโต้งๆเลย)
type TRole = {
  role: string;
}

type TPerson1 = {
  name: string;
} & TRole;

//หรือจะ & ต่อกันไปเลยก็ได้
type TPerson1 = {
  name: string;
} & { role: string };

const person5: TPerson1 = {
  name: "abc",
  role: "admin",
};
```

- Interface ทำได้น้อยกว่า Type-alias พยายามใช้ก่อน ถ้าเจออันไหนที่ Interface ทำไม่ได้ ค่อยไปใช้ Type-alias

- Type-alias จะใช้ใน Advance Type / Map Type / Conditional Type
- Type-alias สามารถทำการกำหนดคำหนึ่งขึ้นมาเพื่อเป็น referrence ที่ชี้ไปยัง type นั้นที่กำหนดไว้

```
// useCase - Type-alias define type-name
//name เป็น Type ที่มีชื่อ Name ที่ชี้ reference ไปที่ string
type Name = string;
const user: { name: Name } = {
  name: "Mr",
};
```

- Union
  - type ทำได้ | interface ทำไม่ได้
  - สามารถเอามาสร้าง type เทพๆได้ เช่่น ดัก parameter ของ Fn ที่จะใส่เข้ามา

```
// useCase - Union
type TAngle = 0 | 90 | 180 | 270 | 360;

function setAngles(angle: TAngle) {}

setAngles(50); // Error: ใส่ parameter ไม่ตรงตามที่เรากำหนดไว้
```

# 1.17.27

#### Discriminated Unions

// Shaping the data model with Interface and Type
// Optionals
// Type Casting: As and As Unknown
// Enums vs Enums with String Values
// Union and Intersection Types (& Discriminated Unions)
// String Unions
// Type Narrowing and Widening
// Strict Mode
// Generic Types
// Using Generics
// Common TS Helper Types (Generics) & How to read generics
// Record, Partial, Readonly, Omit, Pick, Exclude, etc.
// Readonly in Interface
