#### Why TypeScript?

- การทำงานต่อจากคนอื่นโดยทั่วไปยาก เราไม่สามารถรู้ได้ว่าตัวแปรนี้ ชื่อของมันต้องการสื่ออะไร เขาอาจจะตั้งชื่อตัวแปรหลอกเราก็ได้ **Naming Lies**
- Typescript เข้ามาช่วยในการทำงานได้ง่ายขึ้น ระบุTypeของตัวแปรโดยตรงว่าต้องเป็นTypeอะไร

```

uploadFiles(files)
const file = new File()
uploadFile([file])

```

**_void === function ที่ไม่มีการ return อะไรออกมา (undefine)_**

#### You have been using TypeScript all along.

- ใน Javascript ก็มีการใช้ Type อยู่ แต่เป็น type: any _VSCode ใช้ Typescript Complier (จะแสดงใน Tooltip เมื่อเราเอาเมาส์ชี้ไปที่ชื่อ Fn)_

**_ใน comment (/\* \*/) ของJS สามารถใส่ @ ระบุได้ว่าตัวแปรพวกนี้ Type เป็นอะไร เป็นแค่การทำ auto doc (Tooltip VSCode เปลี่ยนด้วย) สำหรับให้คนอื่นเข้าใจ code เราง่ายขึ้น (แต่ไม่ได้ fix ว่าต้องเป็น Type นั้นๆ)_**

**คำสั่ง @**

- @param _variable_(_type_) === กำหนดให้ตัวแปรนั้นๆมี _type_ เป็นอะไร
- @return(_type_) === กำหนดให้การ return ของฟังก์ชันออกมา _type_ เป็นอะไร
- @type {{_variable_: _type_}} === กำหนดให้ตัวแปรใน Object

```

const add1 = (a, b) => a + b;

/**
 * @param a{number}
 * @param b{number}
 * @returns(number)
 */

const add2 = (a, b) => {
  return a + b;
};

```

_เมื่อเอาเมาส์ไปชี้ add1 กับ add2 แสดงผลใน Tooltip ต่างกัน add1 จะเป็น any ทั้งค่าที่รับและค่าที่returnออกมา, add2 จะเป็น number ทั้งหมด_

```

const person1 = {
  nickname: "BOB",
  age: 15,
};

/**
 * @type {{nickname: string}}
 */

const person2 = {
  nickname,
};

```

_person1 เมื่อมีการระบุ property value แล้ว ใน Tooltip จะแสดงผลเป็น Type ของ value นั้นๆ_
_person2 เป็นการใช้ @type ในการระบุ Type ให้กับ property value_

**_ใน TypeScript มีการกำหนด type declaration แยกออกมาจาก File .ts ที่เราเขียน code เป็นหลักได้ > .d.ts (d ย่อมาจาก definition)_**

ในการเริ่มเรียน TypeScript ในช่วงแรกให้เริ่มจากเขียน Javascript ก่อน

###### Type

**Type Inference**: เป็นตัวที่ทำให้ TypeScript จะรู้ได้ว่าฟังก์ชันของเราจะทำอะไร

#### 3 Primitives: Variable Types & Inference

**Primitives**

**Literals**

- เป็นการกำหนดค่าของตัวแปรให้เป็นค่านั้นๆ มีทั้งแบบTypeนั้นเฉยๆ หรือค่าตัวแปรต้องตรง _แบบเปีะๆด้วย (Literally)_

```

const name1 = "Bob Alice"; // name1's Primitives type === "Bob Alice" <- นี่คือ Literals แบบ Literally ที่ต้องเป็นแบบนี้เป๊ะๆ (string คำว่า Bob Alice)

const sayHello = (name: "hello") => `Say ${name}`;
sayHello("hi"); // <- ERROR Fn รับค่าแค่ string: "hello" เท่านั้น

```

###### Developer Experience

```

const sayHello1 = (name: "hello" | "hi") => `Say ${name}`;
sayHello1("hello");

```

- สามารถกำหนดค่าเจาะจงให้กับ TypeScript มากว่า 1 ค่าได้ ด้วย Union _"|"_ -> ทำให้สามารถเลือก parameter ของฟังก์ชันได้ (Auto complete มาจากระบบ Language Server Protocol มีทุก Editor) === _Compile-Time Guarantee_
- _Union ("|")_ ทำงานคล้ายกับหรือ ("||") ใน JavaScript

#### Functions

- ไม่ใส่ return === _void_
- ควรใส่ return Type ให้กับ Fn เมื่อมีการ export ออกมา (กฎ eslint: explicit-module-boundary-type)

**TypeScript Strict Mode**

- โดยปกติ เนื่องจาก TypeScript ต่อยอดมาจาก JavaScript การเขียนcodeเลยไม่เคร่งมากนัก
- Strict Mode จะทำให้ TypeScript เคร่งกฎในการเขียนมากขึ้น

```

npx tsc -init

```

- คำสั่งข้างต้น จะทำการสร้าง tsconfig ขึ้นมา เพื่อเปิดใช้งาน Strict Mode
- Strict Mode ทำให้ code ข้างล่าง Error (ปกติจะไม่ Error)

```

const add2 = (a: number, b: number): number | undefined => {
  return undefined; // Error ถ้าไม่กำหนด Union ตรง Return Type
  return a + b;
};

```

###### Arrays vs Tuples

- ถ้าเราประกาศ declaration Type ไปแล้ว แต่ถ้าทำการ assign ค่าไม่ตรงกับ Type === Error

```

const hello: "hello" = "Hello"; // Error ประกาศ declaration Literals กับ Assign ไม่ตรงกัน

```

**Type number === int, float, negative, zero _เรื่องความกว้าง/แคบของType_**

- Array ประกาศ declaration Type -> **_Type_\[\]** เป็นการประกาศว่า ทุกตัวใน Array ต้อง Type นี้ (ถ้ามากกว่า 1 Type ใช้ Union ได้)
- Nested Array -> **_Type_\[\]\[\]**

```

const birthDay1: number[] = [7, 11, 2001];
const birthDay2: (number | string)[] = [7, 11, 2001];
const nestArr: number[][] = [
  [1, 2],
  [3, 4],
];

```

**TypeScript มีความสามารถคล้ายกับ JavaScript ในการประกาศType Infer Type ดีมาก ถ้าตัว Type ไม่ซับซ้อน**

# STOP AT 32.38

// Any, Unknown, Never, Void
// Null, Undefined
// Inline object typing (fixed keys, string keys; Index Types and Index Signatures)
// Shaping the data model with Interface and Type
// Optionals
// Type Casting: As and As Unknown
// Enums vs Enums with String Values
// Union and Intersection Types (& Discriminated Unions)
// String Unions
// Type Narrowing and Widening
// Strict Mode
// Generic Types
// Using Generics
// Common TS Helper Types (Generics) & How to read generics
// Record, Partial, Readonly, Omit, Pick, Exclude, etc.
// Readonly in Interface
